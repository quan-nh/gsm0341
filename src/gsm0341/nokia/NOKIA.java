package gsm0341.nokia;

//
// This file was generated by the BinaryNotes compiler.
// See http://bnotes.sourceforge.net 
// Any modifications to this file will be lost upon recompilation of the source ASN.1. 
//

import gsm0341.nokia.CellList.CellListSequenceType;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.List;

import org.bn.CoderFactory;
import org.bn.IDecoder;
import org.bn.IEncoder;
import org.bn.annotations.ASN1Module;

@ASN1Module(name = "NOKIA", isImplicitTags = true)
public class NOKIA {

	public static byte[] encodeReset(byte[] cellIdDisc, List<byte[]> cellIds) throws Exception {
		CellIdListDiscBase cellIdListDiscBase = new CellIdListDiscBase();
		cellIdListDiscBase.setValue(cellIdDisc);

		CellIdListDisc cellIdListDisc = new CellIdListDisc();
		cellIdListDisc.setValue(cellIdListDiscBase);

		List<CellListSequenceType> cellListSequenceTypes = new ArrayList<CellListSequenceType>();

		for (byte[] cell : cellIds) {
			CellId cellId = new CellId();
			cellId.setValue(cell);

			CellListSequenceType cellListSequenceType = new CellListSequenceType();
			cellListSequenceType.setId(cellId);

			cellListSequenceTypes.add(cellListSequenceType);
		}

		CellList cellList = new CellList();
		cellList.setDisc(cellIdListDisc);
		cellList.setCellList(cellListSequenceTypes);

		Reset reset = new Reset();
		reset.setCellList(cellList);

		CBSEapdus cbseApdus = new CBSEapdus();
		cbseApdus.selectCbseReset(reset);

		IEncoder<CBSEapdus> encoder = CoderFactory.getInstance().newEncoder("BER");
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		encoder.encode(cbseApdus, outputStream);

		return outputStream.toByteArray();
	}

	public static byte[] encodeStatusCBCHQuery(byte[] cellIdDisc, List<byte[]> cellIds) throws Exception {
		CellIdListDiscBase cellIdListDiscBase = new CellIdListDiscBase();
		cellIdListDiscBase.setValue(cellIdDisc);

		CellIdListDisc cellIdListDisc = new CellIdListDisc();
		cellIdListDisc.setValue(cellIdListDiscBase);

		List<CellListSequenceType> cellListSequenceTypes = new ArrayList<CellListSequenceType>();

		for (byte[] cell : cellIds) {
			CellId cellId = new CellId();
			cellId.setValue(cell);

			CellListSequenceType cellListSequenceType = new CellListSequenceType();
			cellListSequenceType.setId(cellId);

			cellListSequenceTypes.add(cellListSequenceType);
		}

		CellList cellList = new CellList();
		cellList.setDisc(cellIdListDisc);
		cellList.setCellList(cellListSequenceTypes);

		StatusCBCHQuery statusCBCHQuery = new StatusCBCHQuery();
		statusCBCHQuery.setCellList(cellList);

		CBSEapdus cbseApdus = new CBSEapdus();
		cbseApdus.selectCbseStatusCBCHQuery(statusCBCHQuery);

		IEncoder<CBSEapdus> encoder = CoderFactory.getInstance().newEncoder("BER");
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		encoder.encode(cbseApdus, outputStream);

		return outputStream.toByteArray();
	}

	public static boolean isStatusCBCHQueryResp(byte[] data) {
		try {
			CBSEapdus cbseAPDUs = decodeCBSEapdus(data);
			return cbseAPDUs.isCbseStatusCBCHQueryRespSelected();
		} catch (Exception e) {
			return false;
		}
	}

	public static boolean isRestartIndication(byte[] data) {
		try {
			CBSEapdus cbseAPDUs = decodeCBSEapdus(data);
			return cbseAPDUs.isCbseRestartIndicationSelected();
		} catch (Exception e) {
			return false;
		}
	}

	public static boolean isFailureIndication(byte[] data) {
		try {
			CBSEapdus cbseAPDUs = decodeCBSEapdus(data);
			return cbseAPDUs.isCbseFailureIndicationSelected();
		} catch (Exception e) {
			return false;
		}
	}

	public static boolean isReject(byte[] data) {
		try {
			CBSEapdus cbseAPDUs = decodeCBSEapdus(data);
			return cbseAPDUs.isCbseRejectSelected();
		} catch (Exception e) {
			return false;
		}
	}

	private static CBSEapdus decodeCBSEapdus(byte[] data) throws Exception {
		ByteArrayInputStream inputStream = new ByteArrayInputStream(data);

		IDecoder decoder = CoderFactory.getInstance().newDecoder("BER");
		CBSEapdus cbseAPDUs = decoder.decode(inputStream, CBSEapdus.class);

		return cbseAPDUs;
	}

	public static void main(String[] args) throws Exception {
		byte[] cellIdDisc = CellIdListDiscBase.lacAndCi;
		List<byte[]> cellIds = new ArrayList<byte[]>();

		byte[] cellId = new byte[4];
		int lac = 20170;
		int ci = 56093;
		cellId[0] = (byte) ((lac & 0xFF00) >> 8);
		cellId[1] = (byte) (lac & 0x00FF);
		cellId[2] = (byte) ((ci & 0xFF00) >> 8);
		cellId[3] = (byte) (ci & 0x00FF);
		cellIds.add(cellId);

		byte[] reset = encodeReset(cellIdDisc, cellIds);

		System.out.println(byteArrayToString(reset));
		System.out.println(isReject(reset));
	}

	public static String byteArrayToString(byte[] byteArray) {
		StringBuilder builder = new StringBuilder();
		int l = 1;
		for (byte b : byteArray) {
			if ((l != 1) && ((l - 1) % 8 == 0)) {
				builder.append(' ');
			}
			if ((l != 1) && ((l - 1) % 16 == 0)) {
				builder.append('\n');
			}
			l++;
			builder.append("0x");
			String hexString = Integer.toHexString(b & 0xff);
			if (hexString.length() == 1) {
				builder.append(0);
			}
			builder.append(hexString + " ");
		}
		return builder.toString();
	}
}
